[
  {
    "id": 1,
    "name": "Quick Sort",
    "description": "QuickSort is a sorting algorithm based on the Divide and Conquer algorithm that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.",
    "cppImpl": "#include <iostream>\nusing namespace std;\n\nint partition(int arr[], int start, int end)\n{\n\n\tint pivot = arr[start];\n\n\tint count = 0;\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tif (arr[i] <= pivot)\n\t\t\tcount++;\n\t}\n\n\t// Giving pivot element its correct position\n\tint pivotIndex = start + count;\n\tswap(arr[pivotIndex], arr[start]);\n\n\t// Sorting left and right parts of the pivot element\n\tint i = start, j = end;\n\n\twhile (i < pivotIndex && j > pivotIndex) {\n\n\t\twhile (arr[i] <= pivot) {\n\t\t\ti++;\n\t\t}\n\n\t\twhile (arr[j] > pivot) {\n\t\t\tj--;\n\t\t}\n\n\t\tif (i < pivotIndex && j > pivotIndex) {\n\t\t\tswap(arr[i++], arr[j--]);\n\t\t}\n\t}\n\n\treturn pivotIndex;\n}\n\nvoid quickSort(int arr[], int start, int end)\n{\n\n\t// base case\n\tif (start >= end)\n\t\treturn;\n\n\t// partitioning the array\n\tint p = partition(arr, start, end);\n\n\t// Sorting the left part\n\tquickSort(arr, start, p - 1);\n\n\t// Sorting the right part\n\tquickSort(arr, p + 1, end);\n}\n\nint main()\n{\n\n\tint arr[] = { 9, 3, 4, 2, 1, 8 };\n\tint n = 6;\n\n\tquickSort(arr, 0, n - 1);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n\n\treturn 0;\n}\n",
    "pythonImpl": "def partition(array, low, high):\n  pivot = array[high]\n  i = low - 1\n  for j in range(low, high):\n    if array[j] <= pivot:\n      i = i + 1\n      (array[i], array[j]) = (array[j], array[i])\n\n  (array[i + 1], array[high]) = (array[high], array[i + 1])\n\n  return i + 1\n        \ndef quickSort(array, low, high):\n  if low < high:\n\n    pi = partition(array, low, high)\n\n    quickSort(array, low, pi - 1)\n\n    quickSort(array, pi + 1, high)\n        \ndata = [1, 7, 4, 1, 10, 9, -2]\nprint(\"Unsorted Array\")\nprint(data)\n\nsize = len(data)\n\nquickSort(data, 0, size - 1)\n\nprint('Sorted Array in Ascending Order:')\nprint(data)",
    "javaImpl": "class QuickSort\n{\n\ttint partition(int arr[], int low, int high)\n\t{\n\t\tint pivot = arr[high];\n\t\tint i = (low-1); \n\t\tfor (int j=low; j<high; j++)\n\t\t{\n\t\t\tif (arr[j] <= pivot)\n\t\t\t{\n\t\t\t\ti++;\n\n\t\t\t\tint temp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t}\n\t\t}\n\n\t\tint temp = arr[i+1];\n\t\tarr[i+1] = arr[high];\n\t\tarr[high] = temp;\n\n\t\treturn i+1;\n\t}\n\n\n\tvoid sort(int arr[], int low, int high)\n\t{\n\t\tif (low < high)\n\t\t{\n\t\t\t\n\t\t\tint pi = partition(arr, low, high);\n\t\n\t\t\tsort(arr, low, pi-1);\n\t\t\tsort(arr, pi+1, high);\n\t\t}\n\t}\n\n\tstatic void printArray(int arr[])\n\t{\n\t\tint n = arr.length;\n\t\tfor (int i=0; i<n; ++i)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void main(String args[])\n\t{\n\t\tint arr[] = {10, 7, 8, 9, 1, 5};\n\t\tint n = arr.length;\n\n\t\tQuickSort ob = new QuickSort();\n\t\tob.sort(arr, 0, n-1);\n\n\t\tSystem.out.println(\"sorted array\");\n\t\tprintArray(arr);\n\t}\n}\n"
  },
  {
    "id": 2,
    "name": "Bubble Sort",
    "description": "Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity is quite high.",
    "cppImpl": "\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid swap(int* xp, int* yp)\n{\n\tint temp = *xp;\n\t*xp = *yp;\n\t*yp = temp;\n}\n\n// An optimized version of Bubble Sort\nvoid bubbleSort(int arr[], int n)\n{\n\tint i, j;\n\tbool swapped;\n\tfor (i = 0; i < n - 1; i++) {\n\t\tswapped = false;\n\t\tfor (j = 0; j < n - i - 1; j++) {\n\t\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t\tswap(&arr[j], &arr[j + 1]);\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\n\t\t// If no two elements were swapped by inner loop,\n\t\t// then break\n\t\tif (swapped == false)\n\t\t\tbreak;\n\t}\n}\n\n// Function to print an array\nvoid printArray(int arr[], int size)\n{\n\tint i;\n\tfor (i = 0; i < size; i++)\n\t\tprintf(\"%d \", arr[i]);\n}\n\n// Driver program to test above functions\nint main()\n{\n\tint arr[] = { 64, 34, 25, 12, 22, 11, 90 };\n\tint n = sizeof(arr) / sizeof(arr[0]);\n\tbubbleSort(arr, n);\n\tprintf(\"Sorted array: \\n\");\n\tprintArray(arr, n);\n\treturn 0;\n}\n",
    "pythonImpl": "\ndef bubbleSort(arr):\n\tn = len(arr)\n\tswapped = False\n\tfor i in range(n-1):\n\t\tfor j in range(0, n-i-1):\n\t\t\tif arr[j] > arr[j + 1]:\n\t\t\t\tswapped = True\n\t\t\t\tarr[j], arr[j + 1] = arr[j + 1], arr[j]\n\t\t\n\t\tif not swapped:\n\t\t\treturn\n\narr = [64, 34, 25, 12, 22, 11, 90]\n\nbubbleSort(arr)\n\nprint(\"Sorted array is:\")\nfor i in range(len(arr)):\n\tprint(\"% d\" % arr[i], end=\" \")\n",
    "javaImpl": "public class BubbleSortExample {  \n    static void bubbleSort(int[] arr) {  \n        int n = arr.length;  \n        int temp = 0;  \n         for(int i=0; i < n; i++){  \n                 for(int j=1; j < (n-i); j++){  \n                          if(arr[j-1] > arr[j]){  \n                                 //swap elements  \n                                 temp = arr[j-1];  \n                                 arr[j-1] = arr[j];  \n                                 arr[j] = temp;  \n                         }  \n                          \n                 }  \n         }  \n  \n    }  \n    public static void main(String[] args) {  \n                int arr[] ={3,60,35,2,45,320,5};  \n                 \n                System.out.println(\"Array Before Bubble Sort\");  \n                for(int i=0; i < arr.length; i++){  \n                        System.out.print(arr[i] + \" \");  \n                }  \n                System.out.println();  \n                  \n                bubbleSort(arr);//sorting array elements using bubble sort  \n                 \n                System.out.println(\"Array After Bubble Sort\");  \n                for(int i=0; i < arr.length; i++){  \n                        System.out.print(arr[i] + \" \");  \n                }  \n   \n        }  \n}  "
  },
  {
    "id": 3,
    "name": "Merge Sort",
    "description": "Merge Sort is a Divide and Conquer algorithm. It divides the input array into two halves, calls itself the two halves, and then merges the two sorted halves. The merge() function is used for merging two halves. The merge(arr, l, m, r) is a key process that assumes that arr[l..m] and arr[m+1..r] are sorted and merges the two sorted sub-arrays into one. ",
    "cppImpl": "#include <iostream>\nusing namespace std;\n\nvoid merge(int array[], int const left,\n\t\tint const mid, int const right)\n{\n\tauto const subArrayOne = mid - left + 1;\n\tauto const subArrayTwo = right - mid;\n\n\tauto *leftArray = new int[subArrayOne],\n\t\t*rightArray = new int[subArrayTwo];\n\n\tfor (auto i = 0; i < subArrayOne; i++)\n\t\tleftArray[i] = array[left + i];\n\tfor (auto j = 0; j < subArrayTwo; j++)\n\t\trightArray[j] = array[mid + 1 + j];\n\n\tauto indexOfSubArrayOne = 0,\n\t\tindexOfSubArrayTwo = 0;\n\n\tint indexOfMergedArray = left;\n\n\twhile (indexOfSubArrayOne < subArrayOne &&\n\t\tindexOfSubArrayTwo < subArrayTwo)\n\t{\n\t\tif (leftArray[indexOfSubArrayOne] <=\n\t\t\trightArray[indexOfSubArrayTwo])\n\t\t{\n\t\t\tarray[indexOfMergedArray] =\n\t\t\tleftArray[indexOfSubArrayOne];\n\t\t\tindexOfSubArrayOne++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarray[indexOfMergedArray] =\n\t\t\trightArray[indexOfSubArrayTwo];\n\t\t\tindexOfSubArrayTwo++;\n\t\t}\n\t\tindexOfMergedArray++;\n\t}\n\t\n\twhile (indexOfSubArrayOne < subArrayOne)\n\t{\n\t\tarray[indexOfMergedArray] =\n\t\tleftArray[indexOfSubArrayOne];\n\t\tindexOfSubArrayOne++;\n\t\tindexOfMergedArray++;\n\t}\n\n\twhile (indexOfSubArrayTwo < subArrayTwo)\n\t{\n\t\tarray[indexOfMergedArray] =\n\t\trightArray[indexOfSubArrayTwo];\n\t\tindexOfSubArrayTwo++;\n\t\tindexOfMergedArray++;\n\t}\n}\n\nvoid mergeSort(int array[],\n\t\t\tint const begin,\n\t\t\tint const end)\n{\n\tif (begin >= end)\n\t\treturn;\n\n\tauto mid = begin + (end - begin) / 2;\n\tmergeSort(array, begin, mid);\n\tmergeSort(array, mid + 1, end);\n\tmerge(array, begin, mid, end);\n}\n\nvoid printArray(int A[], int size)\n{\n\tfor (auto i = 0; i < size; i++)\n\t\tcout << A[i] << \" \";\n\tcout<<endl;\n}\n\nint main()\n{\n\tint arr[] = { 12, 11, 13, 5, 6, 7 };\n\tauto arr_size = sizeof(arr) / sizeof(arr[0]);\n\n\tcout << \"Given array is \"<<endl;\n\tprintArray(arr, arr_size);\n\n\tmergeSort(arr, 0, arr_size - 1);\n\n\tcout << \"Sorted array is \"<<endl;\n\tprintArray(arr, arr_size);\n\treturn 0;\n}\n",
    "pythonImpl": "\ndef merge(arr, l, m, r):\n\tn1 = m - l + 1\n\tn2 = r - m\n\tL = [0] * (n1)\n\tR = [0] * (n2)\n\tfor i in range(0, n1):\n\t\tL[i] = arr[l + i]\n\n\tfor j in range(0, n2):\n\t\tR[j] = arr[m + 1 + j]\n\n\ti = 0\n\tj = 0\n\tk = l\n\n\twhile i < n1 and j < n2:\n\t\tif L[i] <= R[j]:\n\t\t\tarr[k] = L[i]\n\t\t\ti += 1\n\t\telse:\n\t\t\tarr[k] = R[j]\n\t\t\tj += 1\n\t\tk += 1\n\n\twhile i < n1:\n\t\tarr[k] = L[i]\n\t\ti += 1\n\t\tk += 1\n\n\twhile j < n2:\n\t\tarr[k] = R[j]\n\t\tj += 1\n\t\tk += 1\n\n\ndef mergeSort(arr, l, r):\n\tif l < r:\n\n\t\tm = l+(r-l)//2\n\t\tmergeSort(arr, l, m)\n\t\tmergeSort(arr, m+1, r)\n\t\tmerge(arr, l, m, r)\n\n\narr = [12, 11, 13, 5, 6, 7]\nn = len(arr)\nprint(\"Given array is\")\nfor i in range(n):\n\tprint(\"%d\" % arr[i],end=\" \")\n\nmergeSort(arr, 0, n-1)\nprint(\"\\n\\nSorted array is\")\nfor i in range(n):\n\tprint(\"%d\" % arr[i],end=\" \")",
    "javaImpl": "\nclass MergeSort {\n\n\tvoid merge(int arr[], int l, int m, int r)\n\t{\n\t\tint n1 = m - l + 1;\n\t\tint n2 = r - m;\n\t\tint L[] = new int[n1];\n\t\tint R[] = new int[n2];\n\t\tfor (int i = 0; i < n1; ++i)\n\t\t\tL[i] = arr[l + i];\n\t\tfor (int j = 0; j < n2; ++j)\n\t\t\tR[j] = arr[m + 1 + j];\n\t\tint i = 0, j = 0;\n\t\tint k = l;\n\t\twhile (i < n1 && j < n2) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tarr[k] = L[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarr[k] = R[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\twhile (i < n1) {\n\t\t\tarr[k] = L[i];\n\t\t\ti++;\n\t\t\tk++;\n\t\t}\n\t\twhile (j < n2) {\n\t\t\tarr[k] = R[j];\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t}\n\n\tvoid sort(int arr[], int l, int r)\n\t{\n\t\tif (l < r) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tsort(arr, l, m);\n\t\t\tsort(arr, m + 1, r);\n\t\t\tmerge(arr, l, m, r);\n\t\t}\n\t}\n  \n\tstatic void printArray(int arr[])\n\t{\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void main(String args[])\n\t{\n\t\tint arr[] = { 12, 11, 13, 5, 6, 7 };\n\n\t\tSystem.out.println(\"Given Array\");\n\t\tprintArray(arr);\n\n\t\tMergeSort ob = new MergeSort();\n\t\tob.sort(arr, 0, arr.length - 1);\n\n\t\tSystem.out.println(\"\\nSorted array\");\n\t\tprintArray(arr);\n\t}\n}\n"
  },
  {
    "id": 4,
    "name": "Binary Search",
    "description": "Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). ",
    "cppImpl": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nint binarySearch(int arr[], int l, int r, int x)\n{\n\twhile (l <= r) {\n\t\tint m = l + (r - l) / 2;\n\n\t\tif (arr[m] == x)\n\t\t\treturn m;\n\t\tif (arr[m] < x)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\tr = m - 1;\n\t}\n\treturn -1;\n}\n\nint main(void)\n{\n\tint arr[] = { 2, 3, 4, 10, 40 };\n\tint x = 10;\n\tint n = sizeof(arr) / sizeof(arr[0]);\n\tint result = binarySearch(arr, 0, n - 1, x);\n\t(result == -1)\n\t\t? cout << \"Element is not present in array\"\n\t\t: cout << \"Element is present at index \" << result;\n\treturn 0;\n}\n",
    "pythonImpl": "\ndef binarySearch(arr, l, r, x):\n\n\twhile l <= r:\n\n\t\tmid = l + (r - l) // 2\n\t\tif arr[mid] == x:\n\t\t\treturn mid\n\n\t\telif arr[mid] < x:\n\t\t\tl = mid + 1\n\n\t\telse:\n\t\t\tr = mid - 1\n\n\treturn -1\n\nif __name__ == '__main__':\n\tarr = [2, 3, 4, 10, 40]\n\tx = 10\n\n\tresult = binarySearch(arr, 0, len(arr)-1, x)\n\tif result != -1:\n\t\tprint(\"Element is present at index\", result)\n\telse:\n\t\tprint(\"Element is not present in array\")\n",
    "javaImpl": "\nimport java.io.*;\n\nclass BinarySearch {\n\n\tint binarySearch(int arr[], int x)\n\t{\n\t\tint l = 0, r = arr.length - 1;\n\t\twhile (l <= r) {\n\t\t\tint m = l + (r - l) / 2;\n\n\t\t\tif (arr[m] == x)\n\t\t\t\treturn m;\n\n\t\t\tif (arr[m] < x)\n\t\t\t\tl = m + 1;\n\n\t\t\telse\n\t\t\t\tr = m - 1;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String args[])\n\t{\n\t\tBinarySearch ob = new BinarySearch();\n\t\tint arr[] = { 2, 3, 4, 10, 40 };\n\t\tint n = arr.length;\n\t\tint x = 10;\n\t\tint result = ob.binarySearch(arr, x);\n\t\tif (result == -1)\n\t\t\tSystem.out.println(\n\t\t\t\t\"Element is not present in array\");\n\t\telse\n\t\t\tSystem.out.println(\"Element is present at \"\n\t\t\t\t\t\t\t+ \"index \" + result);\n\t}\n}\n"
  },
  {
    "id": 5,
    "name": "Fibonacci",
    "description": "The Fibonacci numbers are the numbers in the following integer sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ……..",
    "cppImpl": "#include <bits/stdc++.h>\nusing namespace std;\n\nint fib(int n)\n{\n\tint a = 0, b = 1, c, i;\n\tif (n == 0)\n\t\treturn a;\n\tfor (i = 2; i <= n; i++) {\n\t\tc = a + b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn b;\n}\n\nint main()\n{\n\tint n = 9;\n\n\tcout << fib(n);\n\treturn 0;\n}\n\n// This code is contributed by Code_Mech\n",
    "pythonImpl": "def fibonacci(n):\n\ta = 0\n\tb = 1\n\tif n < 0:\n\t\tprint(\"Incorrect input\")\n\telif n == 0:\n\t\treturn a\n\telif n == 1:\n\t\treturn b\n\telse:\n\t\tfor i in range(2, n+1):\n\t\t\tc = a + b\n\t\t\ta = b\n\t\t\tb = c\n\t\treturn b\n\nprint(fibonacci(9))\n",
    "javaImpl": "public class fibonacci {\n\tstatic int fib(int n)\n\t{\n\t\tint a = 0, b = 1, c;\n\t\tif (n == 0)\n\t\t\treturn a;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tc = a + b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn b;\n\t}\n\n\tpublic static void main(String args[])\n\t{\n\t\tint n = 9;\n\t\tSystem.out.println(fib(n));\n\t}\n};\n\n"
  },
  {
    "id": 6,
    "name": "Minimal Cost Path",
    "description": "Given a cost matrix cost[][] and a position (M, N) in cost[][], write a function that returns cost of minimum cost path to reach (M, N) from (0, 0). Each cell of the matrix represents a cost to traverse through that cell. The total cost of a path to reach (M, N) is the sum of all the costs on that path (including both source and destination). You can only traverse down, right and diagonally lower cells from a given cell, i.e., from a given cell (i, j), cells (i+1, j), (i, j+1), and (i+1, j+1) can be traversed. ",
    "cppImpl": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define R 3\n#define C 3\n\nint min(int x, int y, int z);\n\nint minCost(int cost[R][C], int m, int n)\n{\n\tif (n < 0 || m < 0)\n\t\treturn INT_MAX;\n\telse if (m == 0 && n == 0)\n\t\treturn cost[m][n];\n\telse\n\t\treturn cost[m][n]\n\t\t\t+ min(minCost(cost, m - 1, n - 1),\n\t\t\t\t\tminCost(cost, m - 1, n),\n\t\t\t\t\tminCost(cost, m, n - 1));\n}\n\nint min(int x, int y, int z)\n{\n\tif (x < y)\n\t\treturn (x < z) ? x : z;\n\telse\n\t\treturn (y < z) ? y : z;\n}\n\nint main()\n{\n\tint cost[R][C]\n\t\t= { { 1, 2, 3 }, { 4, 8, 2 }, { 1, 5, 3 } };\n\n\tcout << minCost(cost, 2, 2) << endl;\n\n\treturn 0;\n}",
    "pythonImpl": "import sys\nR = 3\nC = 3\n\ndef minCost(cost, m, n):\n\tif (n < 0 or m < 0):\n\t\treturn sys.maxsize\n\telif (m == 0 and n == 0):\n\t\treturn cost[m][n]\n\telse:\n\t\treturn cost[m][n] + min(minCost(cost, m-1, n-1),\n\t\t\t\t\t\t\t\tminCost(cost, m-1, n),\n\t\t\t\t\t\t\t\tminCost(cost, m, n-1))\n\ndef min(x, y, z):\n\tif (x < y):\n\t\treturn x if (x < z) else z\n\telse:\n\t\treturn y if (y < z) else z\n\ncost = [[1, 2, 3],\n\t\t[4, 8, 2],\n\t\t[1, 5, 3]]\nprint(minCost(cost, 2, 2))\n",
    "javaImpl": "public class GFG {\n\n\tstatic int min(int x, int y, int z)\n\t{\n\t\tif (x < y)\n\t\t\treturn (x < z) ? x : z;\n\t\telse\n\t\t\treturn (y < z) ? y : z;\n\t}\n\n\tstatic int minCost(int cost[][], int m, int n)\n\t{\n\t\tif (n < 0 || m < 0)\n\t\t\treturn Integer.MAX_VALUE;\n\t\telse if (m == 0 && n == 0)\n\t\t\treturn cost[m][n];\n\t\telse\n\t\t\treturn cost[m][n]\n\t\t\t\t+ min(minCost(cost, m - 1, n - 1),\n\t\t\t\t\tminCost(cost, m - 1, n),\n\t\t\t\t\tminCost(cost, m, n - 1));\n\t}\n\n\tpublic static void main(String args[])\n\t{\n\n\t\tint cost[][]\n\t\t\t= { { 1, 2, 3 }, { 4, 8, 2 }, { 1, 5, 3 } };\n\n\t\tSystem.out.print(minCost(cost, 2, 2));\n\t}\n}"
  }
]


